use compiler_utils
use cst
use ..comment
use ..declarations
use ..errors
use ..expressions
use ..file
use ..node
use ..types

public fun lowerCstToAst(
  file: File,
  cst: CstNode<CstFile>,
): (AstFile, Map<CstNodeId, AstNodeId>, List<CompilerError>) {
  let context = LoweringContext.create(file)
  let ast = lowerFile(context, cst)
  let trackingResult = context.getResult()
  Tuple(ast, trackingResult.first, trackingResult.second)
}

// file

fun lowerFile(context: LoweringContext, cst: CstNode<CstFile>): AstFile {
  let id = AstFileId(context.file)

  mut let sawDeclaration = false
  let useLines = MutableList.empty<AstUseLine>()
  let declarations = MutableList.empty<AstModule | AstTrait | AstImpl | AstClass | AstFunction | AstProperty>()
  for node in cst.child.content {
    if node.child is CstUseLine {
      if sawDeclaration {
        context.addError(
          UseLineAfterDeclarationCompilerError(context.file, node.cast<CstUseLine>()),
        )
      }

      let result = lowerUseLine(
        context,
        id,
        node.cast<CstUseLine>(),
        (useLines as Iterable<AstUseLine>).length(),
      )
      if result is Some<AstUseLine> {
        useLines.append(result.unwrap())
      }
    } else {
      sawDeclaration = true
    }
  }

  context.addIdMapping(cst.id, id)
  AstFile(id, useLines, declarations)
}

fun lowerUseLine(
  context: LoweringContext,
  fileId: AstFileId,
  cst: CstNode<CstUseLine>,
  useLineIndex: Int,
): Maybe<AstUseLine> {
  let id = AstUseLineId(fileId, useLineIndex)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)
  let target = cst.child.target
      .map<AstUseLineTarget>({
        if it.child is CstLocalRelativeUseLineTarget {
          lowerLocalRelativeUseLineTarget(context, id, it.cast<CstLocalRelativeUseLineTarget>())
        } else {
          lowerGlobalUseLineTarget(context, id, it.cast<CstGlobalUseLineTarget>())
        }
      })

  if target is None<AstUseLineTarget> { return None<AstUseLine>() }

  context.addIdMapping(cst.id, id)
  Some<AstUseLine>(AstUseLine(id, modifiers, target.unwrap()))
}
fun lowerLocalRelativeUseLineTarget(
  context: LoweringContext,
  useLineId: AstUseLineId,
  cst: CstNode<CstLocalRelativeUseLineTarget>,
): AstLocalRelativeUseLineTarget {
  let id = AstUseLineTargetId(useLineId)

  let parentNavigationsIterable = cst.child.parentNavigations as Iterable<CstNode<PunctuationToken>>
  assert(parentNavigationsIterable.isNotEmpty(), "Parent navigations may not be empty.")
  let parentNavigations = parentNavigationsIterable.length() - 1

  let path = MutableList.empty<AstIdentifier>()
  mut let punctuationExpectedNext = false
  for node in cst.child.path {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        /// TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        /// TODO(JonasWanke)
      } else {
        let identifierId = AstIdentifierId(id, (path as Iterable<AstIdentifier>).length())
        path.append(
          AstIdentifier(identifierId, (node.cast<IdentifierToken>()).child.identifier),
        )
        punctuationExpectedNext = true
      }
    }
  }
  if !punctuationExpectedNext {
    // TODO(JonasWanke)
  }

  context.addIdMapping(cst.id, id)
  AstLocalRelativeUseLineTarget(id, parentNavigations, path)
}
fun lowerGlobalUseLineTarget(
  context: LoweringContext,
  useLineId: AstUseLineId,
  cst: CstNode<CstGlobalUseLineTarget>,
): AstGlobalUseLineTarget {
  let id = AstUseLineTargetId(useLineId)

  let packagePath = MutableList.empty<AstIdentifier>()
  mut let punctuationExpectedNext = false
  for node in cst.child.packagePath {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        /// TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        /// TODO(JonasWanke)
      } else {
        let identifierId = AstIdentifierId(id, (packagePath as Iterable<AstIdentifier>).length())
        packagePath.append(
          AstIdentifier(identifierId, node.cast<IdentifierToken>().child.identifier),
        )
        punctuationExpectedNext = true
      }
    }
  }
  if !punctuationExpectedNext {
    // TODO(JonasWanke)
  }

  let moduleName = None<AstIdentifier>()

  context.addIdMapping(cst.id, id)
  AstGlobalUseLineTarget(id, packagePath, moduleName)
}

fun lowerModifiers(
  context: LoweringContext,
  parentId: AstUseLineId | AstDeclarationId | AstTypeParameterId | AstValueParameterId | AstTypeId | AstExpressionId,
  modifiers: List<CstNode<IdentifierToken>>,
): List<AstIdentifier> {
  mut let index = 0
  mut let result = MutableList.empty<AstIdentifier>()
  for modifier in modifiers {
    result.append(lowerModifier(context, parentId, modifier, index))
    index = index + 1
  }
  result
}
fun lowerModifier(
  context: LoweringContext,
  parentId: AstUseLineId | AstDeclarationId | AstTypeParameterId | AstValueParameterId | AstTypeId | AstExpressionId,
  cst: CstNode<IdentifierToken>,
  index: Int,
): AstIdentifier {
  let id = AstIdentifierId(parentId, index)
  context.addIdMapping(cst.id, id)
  AstIdentifier(id, cst.child.identifier)
}

// declarations

fun lowerDeclaration(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstDeclaration>,
  previousNames: Map<String, Bool>,
): AstDeclaration {
  if cst.child is CstModule {
    return lowerModule(context, parentId, cst.cast<CstModule>(), previousNames)
  }
  if cst.child is CstTrait {
    return lowerTrait(context, parentId, cst.cast<CstTrait>(), previousNames)
  }
  if cst.child is CstImpl {
    return lowerImpl(context, parentId, cst.cast<CstImpl>())
  }
  if cst.child is CstClass {
    return lowerClass(context, parentId, cst.cast<CstClass>(), previousNames)
  }
  throw "Unknown declaration: {cst}."
}
fun lowerModule(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstModule>,
  previousNames: Map<String, Bool>,
): AstModule {
  let name = cst.child.name
      .map<String>({ it.child.identifier })
      .orElse({ "unnamed-module-{context.getUnnamedDeclarationIndex()}" })
  let id = AstDeclarationId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({
    let identifierId = AstIdentifierId(id, 0)
    context.addIdMapping(it.id, identifierId)
    AstIdentifier(identifierId, it.child.identifier)
  })
  if name is None<AstIdentifier> {
    context.addError(MissingDeclarationNameCompilerError(context.file, cst.cast<CstDeclaration>()))
  } else {
    if previousNames.containsKey(name.unwrap().value) {
      context.addError(
        DuplicateDeclarationNameCompilerError(
          context.file,
          cst.cast<CstModule | CstTrait | CstClass | CstProperty>(),
        ),
      )
    }
  }

  let innerDeclarations = lowerDeclarationContent(context, id, cst.child.content, true, true) as List<AstModule | AstTrait | AstImpl | AstClass | AstFunction | AstProperty>

  context.addIdMapping(cst.id, id)
  AstModule(id, None<AstCandyDoc>(), modifiers, name, innerDeclarations)
}
fun lowerTrait(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstTrait>,
  previousNames: Map<String, Bool>,
): AstTrait {
  let name = cst.child.name
      .map<String>({ it.child.identifier })
      .orElse({ "unnamed-trait-{context.getUnnamedDeclarationIndex()}" })
  let id = AstDeclarationId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({
    let identifierId = AstIdentifierId(id, 0)
    context.addIdMapping(it.id, identifierId)
    AstIdentifier(identifierId, it.child.identifier)
  })
  if name is None<AstIdentifier> {
    context.addError(MissingDeclarationNameCompilerError(context.file, cst.cast<CstDeclaration>()))
  } else {
    if previousNames.containsKey(name.unwrap().value) {
      context.addError(
        DuplicateDeclarationNameCompilerError(
          context.file,
          cst.cast<CstModule | CstTrait | CstClass | CstProperty>(),
        ),
      )
    }
  }

  let typeParameters = cst.child.typeParameters
      .map<List<AstTypeParameter>>({ lowerTypeParameters(context, id, it) })
      .orElse({ List.empty<AstTypeParameter>() })

  let upperBound = cst.child.upperBound
      .flatMap<AstType>({
        if it.second is None<CstNode<CstType>> {
          context.addError(
            ExpectedTypeCompilerError(
              context.file,
              cst.cast<CstTrait | CstImpl | CstIntersectionType | CstUnionType>(),
            ),
          )
          None<AstType>()
        } else {
          lowerType(context, id, it.second.unwrap())
        }
      })

  let innerDeclarations = lowerDeclarationContent(context, id, cst.child.content, false, true) as List<AstTrait | AstClass | AstFunction | AstProperty>

  context.addIdMapping(cst.id, id)
  AstTrait(id, None<AstCandyDoc>(), modifiers, name, typeParameters, upperBound, innerDeclarations)
}
fun lowerImpl(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstImpl>,
): AstImpl {
  let id = AstDeclarationId(parentId, "impl-{context.getUnnamedDeclarationIndex()}")

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let typeParameters = cst.child.typeParameters
      .map<List<AstTypeParameter>>({ lowerTypeParameters(context, id, it) })
      .orElse({ List.empty<AstTypeParameter>() })

  let type = if cst.child.type is Some<CstNode<CstType>> {
    lowerType(context, id, cst.child.type.unwrap())
  } else {
    context.addError(
      ExpectedTypeCompilerError(
        context.file,
        cst.cast<CstTrait | CstImpl | CstIntersectionType | CstUnionType>(),
      ),
    )
    None<AstType>()
  }

  let traits = cst.child.traits
      .flatMap<AstType>({
        if it.second is None<CstNode<CstType>> {
          context.addError(
            ExpectedTypeCompilerError(
              context.file,
              cst.cast<CstTrait | CstImpl | CstIntersectionType | CstUnionType>(),
            ),
          )
          None<AstType>()
        } else {
          lowerType(context, id, it.second.unwrap())
        }
      })
      .map<List<AstNamedType>>({
        if it is AstNamedType { return List.of1<AstNamedType>(it as AstNamedType) }
        if it is AstIntersectionType {
          let types = (it as AstIntersectionType).types
          if (types as Iterable<AstType>).any({ !(it is AstNamedType) }) {
            context.addError(InvalidImplementedTraitsCompilerError(context.file, cst))
            return List.empty<AstNamedType>()
          }
          return (types as Iterable<AstType>).cast<AstNamedType>().toList()
        }
        context.addError(InvalidImplementedTraitsCompilerError(context.file, cst))
        return List.empty<AstNamedType>()
      })
      .orElse({ List.empty<AstNamedType>() })

  let innerDeclarations = lowerDeclarationContent(context, id, cst.child.content, false, false) as List<AstFunction | AstProperty>

  context.addIdMapping(cst.id, id)
  AstImpl(id, modifiers, typeParameters, type, traits, innerDeclarations)
}
fun lowerClass(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstClass>,
  previousNames: Map<String, Bool>,
): AstClass {
  let name = cst.child.name
      .map<String>({ it.child.identifier })
      .orElse({ "unnamed-class-{context.getUnnamedDeclarationIndex()}" })
  let id = AstDeclarationId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({
    let identifierId = AstIdentifierId(id, 0)
    context.addIdMapping(it.id, identifierId)
    AstIdentifier(identifierId, it.child.identifier)
  })
  if name is None<AstIdentifier> {
    context.addError(MissingDeclarationNameCompilerError(context.file, cst.cast<CstDeclaration>()))
  } else {
    if previousNames.containsKey(name.unwrap().value) {
      context.addError(
        DuplicateDeclarationNameCompilerError(
          context.file,
          cst.cast<CstModule | CstTrait | CstClass | CstProperty>(),
        ),
      )
    }
  }

  let typeParameters = cst.child.typeParameters
      .map<List<AstTypeParameter>>({ lowerTypeParameters(context, id, it) })
      .orElse({ List.empty<AstTypeParameter>() })

  let innerDeclarations = lowerDeclarationContent(context, id, cst.child.content, false, true) as List<AstTrait | AstClass | AstFunction | AstProperty>

  context.addIdMapping(cst.id, id)
  AstClass(id, None<AstCandyDoc>(), modifiers, name, typeParameters, innerDeclarations)
}
fun lowerDeclarationContent(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: Maybe<CstNode<CstDeclarationContent>>,
  allowModulesAndImpls: Bool,
  allowTraitsAndClasses: Bool,
): List<AstDeclaration> {
  if cst is None<CstNode<CstDeclarationContent>> { return List.empty<AstDeclaration>() }
  let cst = cst.unwrap()

  let result = MutableList.empty<AstDeclaration>()
  let previousNames = MutableMap.empty<String, Bool>()
  for node in cst.child.innerDeclarations {
    let lowered = lowerDeclaration(context, parentId, node, previousNames as Map<String, Bool>)

    mut let isValid = true
    if lowered is AstModule {
      previousNames.set((lowered as AstModule).name.unwrap().value, true)
      if !allowModulesAndImpls { isValid = false }
    }
    if lowered is AstTrait {
      previousNames.set((lowered as AstTrait).name.unwrap().value, true)
      if !allowTraitsAndClasses { isValid = false }
    }
    if isValid {
      result.append(lowered)
    } else {
      context.addError(
        InvalidDeclarationTypeCompilerError(context.file, cst.cast<CstDeclaration>()),
      )
    }
  }

  if cst.child.closingCurlyBrace is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}

fun lowerValueParameters(
  context: LoweringContext,
  parentId: AstDeclarationId | AstExpressionId,
  cst: CstNode<CstValueParameters>,
): List<AstValueParameter> {
  let result = MutableList.empty<AstValueParameter>()
  let previousNames = MutableMap.empty<String, Bool>()
  mut let punctuationExpectedNext = false
  for node in cst.child.valueParameters {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        let node = node.cast<CstValueParameter>()
        let lowered = lowerValueParameter(context, parentId, node, previousNames as Map<String, Bool>)
        if lowered is Some<AstValueParameter> {
          let lowered = lowered.unwrap()
          result.append(lowered)
          previousNames.set(lowered.name.unwrap().value, true)
        }
        punctuationExpectedNext = true
      }
    }
  }

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}
fun lowerValueParameter(
  context: LoweringContext,
  parentId: AstDeclarationId | AstExpressionId,
  cst: CstNode<CstValueParameter>,
  previousNames: Map<String, Bool>,
): Maybe<AstValueParameter> {
  let name = cst.child.name.child.identifier
  if previousNames.containsKey(name) {
    context.addError(DuplicateValueParameterNameCompilerError(context.file, cst))
    return None<AstValueParameter>()
  }

  let id = AstValueParameterId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let nameId = AstIdentifierId(id, 0)
  context.addIdMapping(cst.child.name.id, nameId)
  let name = AstIdentifier(nameId, name)

  // Value parameters only occur in functions and lambdas, which we can differentiate using
  // `parentId`.
  let isFunctionParameter = (parentId is AstDeclarationId)
  let type = if isFunctionParameter {
    if cst.child.type is None<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)> {
      context.addError(FunctionValueParameterTypeMissingCompilerError(context.file, cst))
      None<AstType>()
    } else {
      if cst.child.type.unwrap().second is None<CstNode<CstType>> {
        context.addError(FunctionValueParameterTypeMissingCompilerError(context.file, cst))
        None<AstType>()
      } else {
        lowerType(context, id, cst.child.type.unwrap().second.unwrap())
      }
    }
  } else {
    if cst.child.type is None<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)> {
      None<AstType>()
    } else {
      if cst.child.type.unwrap().second is None<CstNode<CstType>> {
        context.addError(LambdaValueParameterTypeExpectedCompilerError(context.file, cst))
        None<AstType>()
      } else {
        lowerType(context, id, cst.child.type.unwrap().second.unwrap())
      }
    }
  }

  let defaultValue = cst.child.defaultValue
      .flatMap<AstExpression>({
        if it.child.expression is None<CstNode<CstExpression>> {
          context.addError(
            ExpectedExpressionCompilerError(
              context.file,
              it.cast<CstExpressionBody | CstDelegationBody>(),
            ),
          )
          None<AstExpression>()
        } else {
          lowerExpression(context, id, it.child.expression.unwrap())
        }
      })

  context.addIdMapping(cst.id, id)
  Some<AstValueParameter>(
    AstValueParameter(id, modifiers, Some<AstIdentifier>(name), type, defaultValue),
  )
}

// types

fun lowerType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstType>,
): Maybe<AstType> {
  if cst.child is CstNamedType {
    return Some<AstType>(lowerNamedType(context, parentId, cst.cast<CstNamedType>()))
  }
  if cst.child is CstGroupType {
    return lowerGroupType(context, parentId, cst.cast<CstGroupType>())
  }
  if cst.child is CstFunctionType {
    return Some<AstType>(lowerFunctionType(context, parentId, cst.cast<CstFunctionType>()))
  }
  if cst.child is CstTupleType {
    return Some<AstType>(lowerTupleType(context, parentId, cst.cast<CstTupleType>()))
  }
  if cst.child is CstIntersectionType {
    return Some<AstType>(lowerIntersectionType(context, parentId, cst.cast<CstIntersectionType>()))
  }
  if cst.child is CstUnionType {
    return Some<AstType>(lowerUnionType(context, parentId, cst.cast<CstUnionType>()))
  }
  throw "Unknown expression: {cst}."
}
fun lowerNamedType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstNamedType>,
): AstNamedType {
  let id = context.getTypeId(parentId)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let nameParts = MutableList.empty<AstIdentifier>()
  mut let punctuationExpectedNext = false
  for node in cst.child.nameParts {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        let identifierId = AstIdentifierId(id, (nameParts as Iterable<AstIdentifier>).length())
        nameParts.append(
          AstIdentifier(identifierId, node.cast<IdentifierToken>().child.identifier),
        )
        punctuationExpectedNext = true
      }
    }
  }
  if !punctuationExpectedNext {
    // TODO(JonasWanke)
  }

  let typeArguments = cst.child.typeArguments
      .map<List<AstTypeArgument>>({ lowerTypeArguments(context, id, it) })
      .orElse({ List.empty<AstTypeArgument>() })

  context.addIdMapping(cst.id, id)
  AstNamedType(id, modifiers, nameParts, typeArguments)
}
fun lowerGroupType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstGroupType>,
): Maybe<AstType> {
  // TODO(JonasWanke): support modifiers on group types
  let groupTypeCst = cst.cast<CstGroupType>()
  if groupTypeCst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = groupTypeCst.cast<CstDeclarationContent
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  if groupTypeCst.child.type is None<CstNode<CstType>> {
    context.addError(ExpectedTypeInGroupTypeCompilerError(context.file, cst))
  }
  return groupTypeCst
      .child
      .type
      .flatMap<AstType>({ lowerType(context, parentId, it) })
}
fun lowerFunctionType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstFunctionType>,
): AstFunctionType {
  let id = context.getTypeId(parentId)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let receiverType = cst.child.receiverType
      .flatMap<AstType>({ lowerType(context, id, it) })

  let parameterTypes = cst.child.parameterTypes
      .map<List<AstType>>({ lowerFunctionTypeParameterTypes(context, id, it) })
      .orElse({
        context.addError(ExpectedParameterTypesInFunctionTypeCompilerError(context.file, cst))
        List.empty<AstType>()
      })

  let returnType = cst.child.returnType
      .map<Maybe<AstType>>({ lowerType(context, id, it) })
      .orElse({
        context.addError(ExpectedReturnTypeInFunctionTypeCompilerError(context.file, cst))
        None<AstType>()
      })

  context.addIdMapping(cst.id, id)
  AstFunctionType(id, modifiers, receiverType, parameterTypes, returnType)
}
fun lowerFunctionTypeParameterTypes(
  context: LoweringContext,
  parentId: AstTypeId,
  cst: CstNode<CstFunctionTypeParameterTypes>,
): List<AstType> {
  let parameterTypes = MutableList.empty<AstType>()
  mut let punctuationExpectedNext = false
  for node in cst.child.parameterTypes {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        let type = lowerType(context, parentId, node.cast<CstType>())
        if type is Some<AstType> { parameterTypes.append(type.unwrap()) }
        punctuationExpectedNext = true
      }
    }
  }

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  parameterTypes
}
fun lowerTupleType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstTupleType>,
): AstTupleType {
  let id = context.getTypeId(parentId)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let types = MutableList.empty<AstType>()
  mut let punctuationExpectedNext = false
  for node in cst.child.types {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        let type = lowerType(context, parentId, node.cast<CstType>())
        if type is Some<AstType> { types.append(type.unwrap()) }
        punctuationExpectedNext = true
      }
    }
  }
  if (types as Iterable<AstType>).length() < 2 {
    context.addError(ExpectedTwoOrMoreTypesInTupleTypeCompilerError(context.file, cst))
  }

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  context.addIdMapping(cst.id, id)
  AstTupleType(id, modifiers, types)
}
fun lowerIntersectionType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstIntersectionType>,
): AstIntersectionType {
  let id = context.getTypeId(parentId)

  let types = MutableList.empty<AstType>()
  let appendType = { type: AstType =>
    if type is AstIntersectionType {
      types.appendAll((type as AstIntersectionType).types as Iterable<AstType>)
      context.removeTypeIdMapping((type as AstIntersectionType).id)
    } else {
      types.append(type)
    }
  }

  let leftType = lowerType(context, id, cst.child.leftType)
  if leftType is Some<AstType> { appendType(leftType.unwrap()) }

  if cst.child.rightType is None<CstNode<CstType>> {
    context.addError(
      ExpectedTypeCompilerError(
        context.file,
        cst.cast<CstTrait | CstImpl | CstIntersectionType | CstUnionType>(),
      ),
    )
  } else {
    let rightType = lowerType(context, id, cst.child.rightType.unwrap())
    if rightType is Some<AstType> { appendType(rightType.unwrap()) }
  }

  context.addIdMapping(cst.id, id)
  AstIntersectionType(id, List.empty<AstIdentifier>(), types)
}
fun lowerUnionType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstUnionType>,
): AstUnionType {
  let id = context.getTypeId(parentId)

  let types = MutableList.empty<AstType>()
  let appendType = { type: AstType =>
    if type is AstUnionType {
      types.appendAll((type as AstUnionType).types as Iterable<AstType>)
      context.removeTypeIdMapping((type as AstUnionType).id)
    } else {
      types.append(type)
    }
  }

  let leftType = lowerType(context, id, cst.child.leftType)
  if leftType is Some<AstType> { appendType(leftType.unwrap()) }

  if cst.child.rightType is None<CstNode<CstType>> {
    context.addError(
      ExpectedTypeCompilerError(
        context.file,
        cst.cast<CstTrait | CstImpl | CstIntersectionType | CstUnionType>(),
      ),
    )
  } else {
    let rightType = lowerType(context, id, cst.child.rightType.unwrap())
    if rightType is Some<AstType> { appendType(rightType.unwrap()) }
  }

  context.addIdMapping(cst.id, id)
  AstUnionType(id, List.empty<AstIdentifier>(), types)
}

fun lowerTypeParameters(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: CstNode<CstTypeParameters>,
): List<AstTypeParameter> {
  let result = MutableList.empty<AstTypeParameter>()
  let previousNames = MutableMap.empty<String, Bool>()
  mut let punctuationExpectedNext = false
  for node in cst.child.typeParameters {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        let node = node.cast<CstTypeParameter>()
        let lowered = lowerTypeParameter(context, parentId, node, previousNames as Map<String, Bool>)
        if lowered is Some<AstTypeParameter> {
          let unwrapped = lowered.unwrap()
          result.append(unwrapped)
          if unwrapped.name is Some<AstIdentifier> {
            previousNames.set(unwrapped.name.unwrap().value, true)
          }
        }
        punctuationExpectedNext = true
      }
    }
  }

  if cst.child.closingAngleBracket is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}
fun lowerTypeParameter(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: CstNode<CstTypeParameter>,
  previousNames: Map<String, Bool>,
): Maybe<AstTypeParameter> {
  let name = cst.child.name
      .map<String>({ it.child.identifier })
      .orElse({ "unnamed-type-parameter-{context.getUnnamedDeclarationIndex()}" })
  if previousNames.containsKey(name) {
    context.addError(DuplicateTypeParameterNameCompilerError(context.file, cst))
    return None<AstTypeParameter>()
  }
  let id = AstTypeParameterId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({
    let identifierId = AstIdentifierId(id, 0)
    context.addIdMapping(it.id, identifierId)
    AstIdentifier(identifierId, it.child.identifier)
  })

  let upperBound = cst.child.upperBound
      .flatMap<AstType>({
        if it.second is None<CstNode<CstType>> {
          context.addError(ExpectedTypeInTypeParameterCompilerError(context.file, cst))
          None<AstType>()
        } else {
          lowerType(context, id, it.second.unwrap())
        }
      })

  context.addIdMapping(cst.id, id)
  Some<AstTypeParameter>(AstTypeParameter(id, modifiers, name, upperBound))
}

fun lowerTypeArguments(
  context: LoweringContext,
  parentId: AstTypeId | AstExpressionId,
  cst: CstNode<CstTypeArguments>,
): List<AstTypeArgument> {
  mut let index = 0
  let result = MutableList.empty<AstTypeArgument>()
  mut let punctuationExpectedNext = false
  for node in cst.child.typeArguments {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        let node = node.cast<CstTypeArgument>()
        result.append(lowerTypeArgument(context, parentId, node, index))
        index = index + 1
        punctuationExpectedNext = true
      }
    }
  }

  if cst.child.closingAngleBracket is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}
fun lowerTypeArgument(
  context: LoweringContext,
  parentId: AstTypeId | AstExpressionId,
  cst: CstNode<CstTypeArgument>,
  index: Int,
): AstTypeArgument {
  let id = AstTypeArgumentId(parentId, index)

  let type = lowerType(context, id, cst.child.type)

  context.addIdMapping(cst.id, id)
  AstTypeArgument(id, type)
}

// expressions

fun lowerExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstValueParameterId,
  cst: CstNode<CstExpression>,
): AstExpression {
  if cst.child is CstIntExpression {
    return lowerIntExpression(context, parentId, cst.cast<CstIntExpression>())
  }
  if cst.child is CstStringExpression {
    return lowerStringExpression(context, parentId, cst.cast<CstStringExpression>())
  }
  throw "Unknown expression: {cst}."
}

fun lowerIntExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstValueParameterId,
  cst: CstNode<CstIntExpression>,
): AstIntExpression {
  let id = context.getExpressionId(parentId)
  context.addIdMapping(cst.id, id)
  AstIntExpression(id, cst.child.value.child.value)
}

fun lowerStringExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstValueParameterId,
  cst: CstNode<CstStringExpression>,
): AstStringExpression {
  let id = context.getExpressionId(parentId)

  let parts = (cst.child.parts as Iterable<CstNode<StringPart>>)
      .map<AstStringPart>({
        if it.child is CstLiteralStringPart {
          return lowerLiteralStringPart(context, parentId, it.cast<CstLiteralStringPart>())
        }
        if it.child is CstEscapedStringPart {
          return lowerEscapedStringPart(context, parentId, it.cast<CstEscapedStringPart>())
        }
        if it.child is CstInterpolatedStringPart {
          return lowerInterpolatedStringPart(
            context,
            parentId,
            it.cast<CstInterpolatedStringPart>(),
          )
        }
        throw "Unknown string part: {it}."
      })
      .toList()

  context.addIdMapping(cst.id, id)
  AstStringExpression(id, parts)
}
fun lowerLiteralStringPart(
  context: LoweringContext,
  parentId: AstDeclarationId | AstValueParameterId,
  cst: CstNode<CstLiteralStringPart>,
): AstStringPart {
  let id = context.getExpressionId(parentId)

  let identifierId = AstIdentifierId(id, 0)
  context.addIdMapping(cst.child.value.id, identifierId)
  let identifier = AstIdentifier(identifierId, cst.child.value.child.value)

  context.addIdMapping(cst.id, id)
  AstLiteralStringPart(id, identifier)
}
fun lowerEscapedStringPart(
  context: LoweringContext,
  parentId: AstDeclarationId | AstValueParameterId,
  cst: CstNode<CstEscapedStringPart>,
): AstStringPart {
  let id = context.getExpressionId(parentId)

  let identifierId = AstIdentifierId(id, 0)
  let value = if cst.child.value is None<CstNode<StringLiteralToken>> {
    context.addError(InvalidEscapeSequenceCompilerError(context.file, cst))
    AstIdentifier(identifierId, "")
  } else {
    let escapeSequence = cst.child.value.unwrap()

    let validEscapeSequences = MutableMap.empty<String, String>()
    validEscapeSequences.set("ü¶Ñ", "\ü¶Ñ")
    validEscapeSequences.set("üëç", "\üëç")
    validEscapeSequences.set("n", "\n")
    validEscapeSequences.set("r", "\r")
    validEscapeSequences.set("t", "\t")
    validEscapeSequences.set("\\", "\\")

    let rawValue = escapeSequence.child.value
    let value = (validEscapeSequences as Map<String, String>)
      .get(rawValue)
      .orElse({
        context.addError(InvalidEscapeSequenceCompilerError(context.file, cst))
        rawValue
      })
    context.addIdMapping(escapeSequence.id, identifierId)
    AstIdentifier(identifierId, value)
  }

  context.addIdMapping(cst.id, id)
  AstLiteralStringPart(id, value)
}
fun lowerInterpolatedStringPart(
  context: LoweringContext,
  parentId: AstDeclarationId | AstValueParameterId,
  cst: CstNode<CstInterpolatedStringPart>,
): AstStringPart {
  let id = context.getExpressionId(parentId)

  if cst.child.closingCurlyBrace is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  context.addIdMapping(cst.id, id)
  if cst.child.expression is Some<CstNode<CstExpression>> {
    let expression = lowerExpression(context, parentId, cst.child.expression.unwrap())
    AstInterpolatedStringPart(id, expression)
  } else {
    context.addError(MissingExpressionInInterpolationCompilerError(context.file, cst))
    AstLiteralStringPart(id, AstIdentifier(AstIdentifierId(id, 0), ""))
  }
}

// utility

class LoweringContext {
  static fun create(file: File): LoweringContext {
    LoweringContext(
      file,
      MutableMap.empty<CstNodeId, AstNodeId>(),
      0,
      0,
      0,
      MutableList.empty<CompilerError>(),
    )
  }

  let file: File

  let idMapping: MutableMap<CstNodeId, AstNodeId>
  fun addIdMapping(cstId: CstNodeId, astId: AstNodeId) {
    assert(
      !(idMapping as Map<CstNodeId, AstNodeId>).containsKey(cstId),
      "ID {cstId} already lowered to {astId}.",
    )
    idMapping.set(cstId, astId)
  }
  fun removeTypeIdMapping(astId: AstTypeId) {
    idMapping.removeWhere({ _, value =>
      if !(value is AstTypeId) { return false }
      // TODO(JonasWanke): this only works because type IDs are currently numbered per file
      (value as AstTypeId).value == astId.value
    })
  }
  mut let nextUnnamedDeclarationIndex: Int
  fun getUnnamedDeclarationIndex(): Int {
    let index = nextUnnamedDeclarationIndex
    nextUnnamedDeclarationIndex = nextUnnamedDeclarationIndex + 1
    index
  }

  mut let nextTypeId: Int
  fun getTypeId(
    parentId: AstDeclarationId
      | AstTypeId
      | AstTypeParameterId
      | AstTypeArgumentId
      | AstValueParameterId
      | AstExpressionId,
    ): AstTypeId {
    // TODO(JonasWanke): number these per parent when IDs implement `Equals & Hash`

    let id = AstTypeId(parentId, nextTypeId)
    nextTypeId = nextTypeId + 1
    id
  }

  mut let nextExpressionId: Int
  fun getExpressionId(parentId: AstDeclarationId | AstValueParameterId): AstExpressionId {
    // TODO(JonasWanke): number these per parent when IDs implement `Equals & Hash`

    let id = AstExpressionId(parentId, nextExpressionId)
    nextExpressionId = nextExpressionId + 1
    id
  }

  let errors: MutableList<CompilerError>
  fun addError(error: CompilerError) { errors.append(error) }

  fun getResult(): (Map<CstNodeId, AstNodeId>, List<CompilerError>) {
    Tuple(idMapping, errors)
  }
}
