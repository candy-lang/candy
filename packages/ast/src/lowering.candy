use compiler_utils
use cst
use ..comment
use ..declarations
use ..errors
use ..expressions
use ..file
use ..node
use ..types

public fun lowerCstToAst(
  file: File,
  cst: CstNode<CstFile>,
): (AstFile, Map<CstNodeId, AstNodeId>, List<CompilerError>) {
  let context = LoweringContext.create(file)
  let ast = lowerFile(context, cst)
  let trackingResult = context.getResult()
  Tuple(ast, trackingResult.first, trackingResult.second)
}

// file

fun lowerFile(context: LoweringContext, cst: CstNode<CstFile>): AstFile {
  let id = AstFileId(context.file)

  mut let sawDeclaration = false
  let useLines = MutableList.empty<AstUseLine>()
  let declarations = MutableList.empty<AstModule | AstTrait | AstImpl | AstClass | AstFunction | AstProperty>()
  let previousDeclarationNames = MutableMap.empty<String, Bool>()
  for node in cst.child.content {
    if node.child is CstUseLine {
      if sawDeclaration {
        context.addError(
          UseLineAfterDeclarationCompilerError(context.file, node.cast<CstUseLine>()),
        )
      }

      let result = lowerUseLine(
        context,
        id,
        node.cast<CstUseLine>(),
        (useLines as Iterable<AstUseLine>).length(),
      )
      if result is Some<AstUseLine> {
        useLines.append(result.unwrap())
      }
    } else {
      sawDeclaration = true
      let result = lowerDeclaration(
        context,
        id,
        node.cast<CstDeclaration>(),
        previousDeclarationNames as Map<String, Bool>,
      )
      if result is Some<AstDeclaration> {
        declarations.append(
          result.unwrap() as AstModule | AstTrait | AstImpl | AstClass | AstFunction | AstProperty,
        )
      }
    }
  }

  context.addIdMapping(cst.id, id)
  AstFile(id, useLines, declarations)
}

fun lowerUseLine(
  context: LoweringContext,
  fileId: AstFileId,
  cst: CstNode<CstUseLine>,
  useLineIndex: Int,
): Maybe<AstUseLine> {
  let id = AstUseLineId(fileId, useLineIndex)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)
  let target = cst.child.target
      .map<AstUseLineTarget>({
        if it.child is CstLocalRelativeUseLineTarget {
          lowerLocalRelativeUseLineTarget(context, id, it.cast<CstLocalRelativeUseLineTarget>())
        } else {
          lowerGlobalUseLineTarget(context, id, it.cast<CstGlobalUseLineTarget>())
        }
      })

  if target is None<AstUseLineTarget> { return None<AstUseLine>() }

  context.addIdMapping(cst.id, id)
  Some<AstUseLine>(AstUseLine(id, modifiers, target.unwrap()))
}
fun lowerLocalRelativeUseLineTarget(
  context: LoweringContext,
  useLineId: AstUseLineId,
  cst: CstNode<CstLocalRelativeUseLineTarget>,
): AstLocalRelativeUseLineTarget {
  let id = AstUseLineTargetId(useLineId)

  let parentNavigationsIterable = cst.child.parentNavigations as Iterable<CstNode<PunctuationToken>>
  assert(parentNavigationsIterable.isNotEmpty(), "Parent navigations may not be empty.")
  let parentNavigations = parentNavigationsIterable.length() - 1

  let path = MutableList.empty<AstIdentifier>()
  mut let punctuationExpectedNext = false
  for node in cst.child.path {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        /// TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        /// TODO(JonasWanke)
      }
      path.append(
        lowerIdentifier(
          context,
          id,
          node.cast<IdentifierToken>(),
          (path as Iterable<AstIdentifier>).length(),
        )
      )
      punctuationExpectedNext = true
    }
  }
  if !punctuationExpectedNext {
    // TODO(JonasWanke)
  }

  context.addIdMapping(cst.id, id)
  AstLocalRelativeUseLineTarget(id, parentNavigations, path)
}
fun lowerGlobalUseLineTarget(
  context: LoweringContext,
  useLineId: AstUseLineId,
  cst: CstNode<CstGlobalUseLineTarget>,
): AstGlobalUseLineTarget {
  let id = AstUseLineTargetId(useLineId)

  let packagePath = MutableList.empty<AstIdentifier>()
  mut let punctuationExpectedNext = false
  for node in cst.child.packagePath {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        /// TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        /// TODO(JonasWanke)
      }
      packagePath.append(
        lowerIdentifier(
          context,
          id,
          node.cast<IdentifierToken>(),
          (packagePath as Iterable<AstIdentifier>).length(),
        )
      )
      punctuationExpectedNext = true
    }
  }
  if !punctuationExpectedNext {
    // TODO(JonasWanke)
  }

  let moduleName = None<AstIdentifier>()

  context.addIdMapping(cst.id, id)
  AstGlobalUseLineTarget(id, packagePath, moduleName)
}

fun lowerModifiers(
  context: LoweringContext,
  parentId: AstUseLineId | AstDeclarationId | AstTypeParameterId | AstValueParameterId | AstTypeId | AstExpressionId,
  modifiers: List<CstNode<IdentifierToken>>,
): List<AstIdentifier> {
  mut let index = 0
  mut let result = MutableList.empty<AstIdentifier>()
  for modifier in modifiers {
    result.append(lowerModifier(context, parentId, modifier, index))
    index = index + 1
  }
  result
}
fun lowerModifier(
  context: LoweringContext,
  parentId: AstUseLineId | AstDeclarationId | AstTypeParameterId | AstValueParameterId | AstTypeId | AstExpressionId,
  cst: CstNode<IdentifierToken>,
  index: Int,
): AstIdentifier { lowerIdentifier(context, parentId, cst, index) }

fun lowerIdentifier(
  context: LoweringContext,
  parentId: AstUseLineId
    | AstUseLineTargetId
    | AstDeclarationId
    | AstTypeParameterId
    | AstValueParameterId
    | AstTypeId
    | AstExpressionId,
  cst: CstNode<IdentifierToken>,
  index: Int,
): AstIdentifier {
  let id = AstIdentifierId(parentId, index)
  context.addIdMapping(cst.id, id)
  AstIdentifier(id, cst.child.identifier)
}

// declarations

fun lowerDeclaration(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstDeclaration>,
  previousNames: Map<String, Bool>,
): Maybe<AstDeclaration> {
  if cst.child is CstModule {
    return lowerModule(context, parentId, cst.cast<CstModule>(), previousNames)
  }
  if cst.child is CstTrait {
    return lowerTrait(context, parentId, cst.cast<CstTrait>(), previousNames)
  }
  if cst.child is CstImpl {
    return lowerImpl(context, parentId, cst.cast<CstImpl>())
  }
  if cst.child is CstClass {
    return lowerClass(context, parentId, cst.cast<CstClass>(), previousNames)
  }
  if cst.child is CstFunction {
    return lowerFunction(context, parentId, cst.cast<CstFunction>())
  }
  if cst.child is CstProperty {
    return lowerProperty(context, parentId, cst.cast<CstProperty>(), previousNames)
  }
  throw "Unknown declaration: {cst}."
}
fun lowerModule(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstModule>,
  previousNames: Map<String, Bool>,
): Maybe<AstModule> {
  let hasName = cst.child.name is Some<CstNode<IdentifierToken>>
  let name = if hasName {
    cst.child.name.unwrap().child.identifier
  } else {
    "unnamed-module-{context.getUnnamedDeclarationIndex()}"
  }
  let id = AstDeclarationId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })
  if !hasName {
    context.addError(MissingDeclarationNameCompilerError(context.file, cst.cast<CstDeclaration>()))
  } else {
    if previousNames.containsKey(name.unwrap().value) {
      context.addError(
        DuplicateDeclarationNameCompilerError(
          context.file,
          cst.cast<CstModule | CstTrait | CstClass | CstProperty>(),
        ),
      )
    }
  }

  let innerDeclarations = lowerDeclarationContent(context, id, cst.child.content, true, true) as List<AstModule | AstTrait | AstImpl | AstClass | AstFunction | AstProperty>

  if !hasName { return None<AstModule>() }
  context.addIdMapping(cst.id, id)
  Some<AstModule>(AstModule(id, None<AstCandyDoc>(), modifiers, name, innerDeclarations))
}
fun lowerTrait(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstTrait>,
  previousNames: Map<String, Bool>,
): Maybe<AstTrait> {
  let hasName = cst.child.name is Some<CstNode<IdentifierToken>>
  let name = if hasName {
    cst.child.name.unwrap().child.identifier
  } else {
    "unnamed-trait-{context.getUnnamedDeclarationIndex()}"
  }
  let id = AstDeclarationId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })
  if !hasName {
    context.addError(MissingDeclarationNameCompilerError(context.file, cst.cast<CstDeclaration>()))
  } else {
    if previousNames.containsKey(name.unwrap().value) {
      context.addError(
        DuplicateDeclarationNameCompilerError(
          context.file,
          cst.cast<CstModule | CstTrait | CstClass | CstProperty>(),
        ),
      )
    }
  }

  let typeParameters = cst.child.typeParameters
      .map<List<AstTypeParameter>>({ lowerTypeParameters(context, id, it) })
      .orElse({ List.empty<AstTypeParameter>() })

  let upperBound = cst.child.upperBound
      .flatMap<AstType>({
        if it.second is None<CstNode<CstType>> {
          context.addError(
            ExpectedTypeCompilerError(
              context.file,
              cst.cast<CstTrait | CstImpl | CstProperty | CstIntersectionType | CstUnionType>(),
            ),
          )
          None<AstType>()
        } else {
          lowerType(context, id, it.second.unwrap())
        }
      })

  let innerDeclarations = lowerDeclarationContent(context, id, cst.child.content, false, true) as List<AstTrait | AstClass | AstFunction | AstProperty>

  if !hasName { return None<AstTrait>() }
  context.addIdMapping(cst.id, id)
  Some<AstTrait>(
    AstTrait(
      id,
      None<AstCandyDoc>(),
      modifiers,
      name,
      typeParameters,
      upperBound,
      innerDeclarations,
    ),
  )
}
fun lowerImpl(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstImpl>,
): Maybe<AstImpl> {
  let id = AstDeclarationId(parentId, "impl-{context.getUnnamedDeclarationIndex()}")

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let typeParameters = cst.child.typeParameters
      .map<List<AstTypeParameter>>({ lowerTypeParameters(context, id, it) })
      .orElse({ List.empty<AstTypeParameter>() })

  let type = if cst.child.type is Some<CstNode<CstType>> {
    lowerType(context, id, cst.child.type.unwrap())
  } else {
    context.addError(
      ExpectedTypeCompilerError(
        context.file,
        cst.cast<CstTrait | CstImpl | CstProperty | CstIntersectionType | CstUnionType>(),
      ),
    )
    None<AstType>()
  }

  let traits = cst.child.traits
      .flatMap<AstType>({
        if it.second is None<CstNode<CstType>> {
          context.addError(
            ExpectedTypeCompilerError(
              context.file,
              cst.cast<CstTrait | CstImpl | CstProperty | CstIntersectionType | CstUnionType>(),
            ),
          )
          None<AstType>()
        } else {
          lowerType(context, id, it.second.unwrap())
        }
      })
      .map<List<AstNamedType>>({
        if it is AstNamedType { return List.of1<AstNamedType>(it as AstNamedType) }
        if it is AstIntersectionType {
          let types = (it as AstIntersectionType).types
          if (types as Iterable<AstType>).any({ !(it is AstNamedType) }) {
            context.addError(InvalidImplementedTraitsCompilerError(context.file, cst))
            return List.empty<AstNamedType>()
          }
          return (types as Iterable<AstType>).cast<AstNamedType>().toList()
        }
        context.addError(InvalidImplementedTraitsCompilerError(context.file, cst))
        return List.empty<AstNamedType>()
      })
      .orElse({ List.empty<AstNamedType>() })

  let innerDeclarations = lowerDeclarationContent(context, id, cst.child.content, false, false) as List<AstFunction | AstProperty>

  context.addIdMapping(cst.id, id)
  Some<AstImpl>(AstImpl(id, modifiers, typeParameters, type, traits, innerDeclarations))
}
fun lowerClass(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstClass>,
  previousNames: Map<String, Bool>,
): Maybe<AstClass> {
  let name = cst.child.name
  let hasName = cst.child.name is Some<CstNode<IdentifierToken>>
  let name = if hasName {
    cst.child.name.unwrap().child.identifier
  } else {
    "unnamed-class-{context.getUnnamedDeclarationIndex()}"
  }
  let id = AstDeclarationId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })
  if !hasName {
    context.addError(MissingDeclarationNameCompilerError(context.file, cst.cast<CstDeclaration>()))
  } else {
    if previousNames.containsKey(name.unwrap().value) {
      context.addError(
        DuplicateDeclarationNameCompilerError(
          context.file,
          cst.cast<CstModule | CstTrait | CstClass | CstProperty>(),
        ),
      )
    }
  }

  let typeParameters = cst.child.typeParameters
      .map<List<AstTypeParameter>>({ lowerTypeParameters(context, id, it) })
      .orElse({ List.empty<AstTypeParameter>() })

  let innerDeclarations = lowerDeclarationContent(context, id, cst.child.content, false, true) as List<AstTrait | AstClass | AstFunction | AstProperty>

  if !hasName { return None<AstClass>() }
  context.addIdMapping(cst.id, id)
  Some<AstClass>(
    AstClass(id, None<AstCandyDoc>(), modifiers, name, typeParameters, innerDeclarations),
  )
}
fun lowerFunction(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstFunction>,
): Maybe<AstFunction> {
  let hasName = cst.child.name is Some<CstNode<IdentifierToken>>
  let name = if hasName {
    cst.child.name.unwrap().child.identifier
  } else {
    "unnamed-function-{context.getUnnamedDeclarationIndex()}"
  }
  let name = "{name}-{context.getUnnamedDeclarationIndex()}"
  let id = AstDeclarationId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })
  if !hasName {
    context.addError(MissingDeclarationNameCompilerError(context.file, cst.cast<CstDeclaration>()))
  }

  let typeParameters = cst.child.typeParameters
      .map<List<AstTypeParameter>>({ lowerTypeParameters(context, id, it) })
      .orElse({ List.empty<AstTypeParameter>() })

  let valueParameters = cst.child.valueParameters
      .map<List<AstValueParameter>>({ lowerValueParameters(context, id, it) })
      .orElse({
        context.addError(MissingValueParametersCompilerError(context.file, cst))
        List.empty<AstValueParameter>()
      })

  let returnType = if cst.child.returnType is None<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)> {
    context.addError(ExpectedFunctionReturnTypeCompilerError(context.file, cst))
    None<AstType>()
  } else {
    let returnType = cst.child.returnType.unwrap()
    if returnType.second is None<CstNode<CstType>> {
      context.addError(ExpectedFunctionReturnTypeCompilerError(context.file, cst))
      None<AstType>()
    } else {
      lowerType(context, id, returnType.second.unwrap())
    }
  }

  let body = if cst.child.body is None<CstNode<CstBlockBody | CstExpressionBody>> {
    None<AstBlockBody | AstExpressionBody | AstDelegationBody>()
  } else {
    let body = cst.child.body.unwrap()
    if body.child is CstBlockBody {
      Some<AstBlockBody | AstExpressionBody | AstDelegationBody>(
        lowerBlockBody(context, id, body.cast<CstBlockBody>()),
      )
    } else {
      Some<AstBlockBody | AstExpressionBody | AstDelegationBody>(
        lowerExpressionBody(context, id, body.cast<CstExpressionBody>()),
      )
    }
  }

  if !hasName { return None<AstFunction>() }
  context.addIdMapping(cst.id, id)
  Some<AstFunction>(
    AstFunction(
      id,
      None<AstCandyDoc>(),
      modifiers,
      name,
      typeParameters,
      valueParameters,
      returnType,
      body,
    ),
  )
}
fun lowerProperty(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstProperty>,
  previousNames: Map<String, Bool>,
): Maybe<AstProperty> {
  let hasName = cst.child.name is Some<CstNode<IdentifierToken>>
  let name = if hasName {
    cst.child.name.unwrap().child.identifier
  } else {
    "unnamed-property-{context.getUnnamedDeclarationIndex()}"
  }
  let id = AstDeclarationId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let isMutable = cst.child.isMutable()

  let name = cst.child.name.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })
  if !hasName {
    context.addError(MissingDeclarationNameCompilerError(context.file, cst.cast<CstDeclaration>()))
  } else {
    if previousNames.containsKey(name.unwrap().value) {
      context.addError(
        DuplicateDeclarationNameCompilerError(
          context.file,
          cst.cast<CstModule | CstTrait | CstClass | CstProperty>(),
        ),
      )
    }
  }

  let type = if cst.child.type is None<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)> {
    None<AstType>()
  } else {
    let type = cst.child.type.unwrap()
    if type.second is None<CstNode<CstType>> {
      context.addError(
        ExpectedTypeCompilerError(
          context.file,
          cst.cast<CstTrait | CstImpl | CstProperty | CstIntersectionType | CstUnionType>(),
        ),
      )
      None<AstType>()
    } else {
      lowerType(context, id, type.second.unwrap())
    }
  }

  let initializer = if cst.child.initializer is None<CstNode<CstDelegationBody>> {
    None<AstExpression>()
  } else {
    let initializer = cst.child.initializer.unwrap()
    if initializer.child.expression is None<CstNode<CstExpression>> {
      context.addError(
        ExpectedExpressionCompilerError(
          context.file,
          initializer.cast<CstExpressionBody | CstDelegationBody | CstGroupExpression>(),
        ),
      )
      None<AstExpression>()
    } else {
      lowerExpression(context, id, initializer.child.expression.unwrap())
    }
  }

  if !hasName { return None<AstProperty>() }
  context.addIdMapping(cst.id, id)
  Some<AstProperty>(
    AstProperty(id, None<AstCandyDoc>(), modifiers, isMutable, name, type, initializer),
  )
}
fun lowerDeclarationContent(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: Maybe<CstNode<CstDeclarationContent>>,
  allowModulesAndImpls: Bool,
  allowTraitsAndClasses: Bool,
): List<AstDeclaration> {
  if cst is None<CstNode<CstDeclarationContent>> { return List.empty<AstDeclaration>() }
  let cst = cst.unwrap()

  let result = MutableList.empty<AstDeclaration>()
  let previousNames = MutableMap.empty<String, Bool>()
  for node in cst.child.innerDeclarations {
    let loweredRaw = lowerDeclaration(context, parentId, node, previousNames as Map<String, Bool>)
    if loweredRaw is None<AstDeclaration> { continue }
    let lowered = loweredRaw.unwrap()

    mut let isValid = true
    if lowered is AstModule {
      previousNames.set((lowered as AstModule).name.unwrap().value, true)
      if !allowModulesAndImpls { isValid = false }
    }
    if lowered is AstTrait {
      previousNames.set((lowered as AstTrait).name.unwrap().value, true)
      if !allowTraitsAndClasses { isValid = false }
    }
    if lowered is AstImpl && !allowModulesAndImpls { isValid = false }
    if lowered is AstClass {
      previousNames.set((lowered as AstClass).name.unwrap().value, true)
      if !allowTraitsAndClasses { isValid = false }
    }
    // Functions and properties are always allowed.
    if isValid {
      result.append(lowered)
    } else {
      context.addError(
        InvalidDeclarationTypeCompilerError(context.file, cst.cast<CstDeclaration>()),
      )
    }
  }

  if cst.child.closingCurlyBrace is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}
fun lowerBlockBody(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: CstNode<CstBlockBody>,
): AstBlockBody {
  let id = AstBodyId(parentId)

  let expressions = (cst.child.expressions as Iterable<CstNode<CstExpression>>)
      .map<Maybe<AstExpression>>({ lowerExpression(context, parentId, it) })
      .where({ it is Some<AstExpression> })
      .map<AstExpression>({ it.unwrap() })
      .toList()

  if cst.child.closingCurlyBrace is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  context.addIdMapping(cst.id, id)
  AstBlockBody(id, expressions)
}
fun lowerExpressionBody(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: CstNode<CstExpressionBody>,
): AstExpressionBody {
  let id = AstBodyId(parentId)

  let expression = if cst.child.expression is None<CstNode<CstExpression>> {
    context.addError(
      ExpectedExpressionCompilerError(
        context.file,
        cst.cast<CstExpressionBody | CstDelegationBody | CstGroupExpression>(),
      ),
    )
    None<AstExpression>()
  } else {
    lowerExpression(context, parentId, cst.child.expression.unwrap())
  }

  context.addIdMapping(cst.id, id)
  AstExpressionBody(id, expression)
}

fun lowerValueParameters(
  context: LoweringContext,
  parentId: AstDeclarationId | AstExpressionId,
  cst: CstNode<CstValueParameters>,
): List<AstValueParameter> {
  let result = lowerValueParameterList(context, parentId, cst.child.valueParameters)

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}
fun lowerValueParameterList(
  context: LoweringContext,
  parentId: AstDeclarationId | AstExpressionId,
  csts: List<CstNode<CstValueParameter | PunctuationToken>>,
): List<AstValueParameter> {
  let result = MutableList.empty<AstValueParameter>()
  let previousNames = MutableMap.empty<String, Bool>()
  mut let punctuationExpectedNext = false
  for node in csts {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      let lowered = lowerValueParameter(
        context,
        parentId,
        node.cast<CstValueParameter>(),
        previousNames as Map<String, Bool>,
      )
      if lowered is Some<AstValueParameter> {
        let lowered = lowered.unwrap()
        result.append(lowered)
        previousNames.set(lowered.name.unwrap().value, true)
      }
      punctuationExpectedNext = true
    }
  }

  result
}
fun lowerValueParameter(
  context: LoweringContext,
  parentId: AstDeclarationId | AstExpressionId,
  cst: CstNode<CstValueParameter>,
  previousNames: Map<String, Bool>,
): Maybe<AstValueParameter> {
  let name = cst.child.name.child.identifier
  if previousNames.containsKey(name) {
    context.addError(DuplicateValueParameterNameCompilerError(context.file, cst))
    return None<AstValueParameter>()
  }

  let id = AstValueParameterId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name =  lowerIdentifier(context, id, cst.child.name, 0)

  // Value parameters only occur in functions and lambdas, which we can differentiate using
  // `parentId`.
  let isFunctionParameter = (parentId is AstDeclarationId)
  let type = if isFunctionParameter {
    if cst.child.type is None<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)> {
      context.addError(FunctionValueParameterTypeMissingCompilerError(context.file, cst))
      None<AstType>()
    } else {
      if cst.child.type.unwrap().second is None<CstNode<CstType>> {
        context.addError(FunctionValueParameterTypeMissingCompilerError(context.file, cst))
        None<AstType>()
      } else {
        lowerType(context, id, cst.child.type.unwrap().second.unwrap())
      }
    }
  } else {
    if cst.child.type is None<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)> {
      None<AstType>()
    } else {
      if cst.child.type.unwrap().second is None<CstNode<CstType>> {
        context.addError(LambdaValueParameterTypeExpectedCompilerError(context.file, cst))
        None<AstType>()
      } else {
        lowerType(context, id, cst.child.type.unwrap().second.unwrap())
      }
    }
  }

  let defaultValue = cst.child.defaultValue
      .flatMap<AstExpression>({
        if it.child.expression is None<CstNode<CstExpression>> {
          context.addError(
            ExpectedExpressionCompilerError(
              context.file,
              it.cast<CstExpressionBody | CstDelegationBody | CstGroupExpression>(),
            ),
          )
          None<AstExpression>()
        } else {
          lowerExpression(context, id, it.child.expression.unwrap())
        }
      })

  context.addIdMapping(cst.id, id)
  Some<AstValueParameter>(
    AstValueParameter(id, modifiers, Some<AstIdentifier>(name), type, defaultValue),
  )
}

// types

fun lowerType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstType>,
): Maybe<AstType> {
  if cst.child is CstNamedType {
    return Some<AstType>(lowerNamedType(context, parentId, cst.cast<CstNamedType>()))
  }
  if cst.child is CstGroupType {
    return lowerGroupType(context, parentId, cst.cast<CstGroupType>())
  }
  if cst.child is CstFunctionType {
    return Some<AstType>(lowerFunctionType(context, parentId, cst.cast<CstFunctionType>()))
  }
  if cst.child is CstTupleType {
    return Some<AstType>(lowerTupleType(context, parentId, cst.cast<CstTupleType>()))
  }
  if cst.child is CstIntersectionType {
    return Some<AstType>(lowerIntersectionType(context, parentId, cst.cast<CstIntersectionType>()))
  }
  if cst.child is CstUnionType {
    return Some<AstType>(lowerUnionType(context, parentId, cst.cast<CstUnionType>()))
  }
  throw "Unknown expression: {cst}."
}
fun lowerNamedType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstNamedType>,
): AstNamedType {
  let id = context.getTypeId(parentId)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let nameParts = MutableList.empty<AstIdentifier>()
  mut let punctuationExpectedNext = false
  for node in cst.child.nameParts {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      nameParts.append(
        lowerIdentifier(
          context,
          id,
          node.cast<IdentifierToken>(),
          (nameParts as Iterable<AstIdentifier>).length(),
        )
      )
      punctuationExpectedNext = true
    }
  }
  if !punctuationExpectedNext {
    // TODO(JonasWanke)
  }

  let typeArguments = cst.child.typeArguments
      .map<List<AstTypeArgument>>({ lowerTypeArguments(context, id, it) })
      .orElse({ List.empty<AstTypeArgument>() })

  context.addIdMapping(cst.id, id)
  AstNamedType(id, modifiers, nameParts, typeArguments)
}
fun lowerGroupType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstGroupType>,
): Maybe<AstType> {
  let type = if cst.child.type is None<CstNode<CstType>> {
    context.addError(ExpectedTypeInGroupTypeCompilerError(context.file, cst))
    None<AstType>()
  } else {
    lowerType(context, parentId, cst.child.type.unwrap())
  }

  // TODO(JonasWanke): support modifiers on group types
  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  type
}
fun lowerFunctionType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstFunctionType>,
): AstFunctionType {
  let id = context.getTypeId(parentId)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let receiverType = cst.child.receiverType
      .flatMap<AstType>({ lowerType(context, id, it) })

  let parameterTypes = cst.child.parameterTypes
      .map<List<AstType>>({ lowerFunctionTypeParameterTypes(context, id, it) })
      .orElse({
        context.addError(ExpectedParameterTypesInFunctionTypeCompilerError(context.file, cst))
        List.empty<AstType>()
      })

  let returnType = cst.child.returnType
      .map<Maybe<AstType>>({ lowerType(context, id, it) })
      .orElse({
        context.addError(ExpectedReturnTypeInFunctionTypeCompilerError(context.file, cst))
        None<AstType>()
      })

  context.addIdMapping(cst.id, id)
  AstFunctionType(id, modifiers, receiverType, parameterTypes, returnType)
}
fun lowerFunctionTypeParameterTypes(
  context: LoweringContext,
  parentId: AstTypeId,
  cst: CstNode<CstFunctionTypeParameterTypes>,
): List<AstType> {
  let parameterTypes = MutableList.empty<AstType>()
  mut let punctuationExpectedNext = false
  for node in cst.child.parameterTypes {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      let type = lowerType(context, parentId, node.cast<CstType>())
      if type is Some<AstType> { parameterTypes.append(type.unwrap()) }
      punctuationExpectedNext = true
    }
  }

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  parameterTypes
}
fun lowerTupleType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstTupleType>,
): AstTupleType {
  let id = context.getTypeId(parentId)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let types = MutableList.empty<AstType>()
  mut let punctuationExpectedNext = false
  for node in cst.child.types {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      let type = lowerType(context, parentId, node.cast<CstType>())
      if type is Some<AstType> { types.append(type.unwrap()) }
      punctuationExpectedNext = true
    }
  }
  if (types as Iterable<AstType>).length() < 2 {
    context.addError(ExpectedTwoOrMoreTypesInTupleTypeCompilerError(context.file, cst))
  }

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  context.addIdMapping(cst.id, id)
  AstTupleType(id, modifiers, types)
}
fun lowerIntersectionType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstIntersectionType>,
): AstIntersectionType {
  let id = context.getTypeId(parentId)

  let types = MutableList.empty<AstType>()
  let appendType = { type: AstType =>
    if type is AstIntersectionType {
      types.appendAll((type as AstIntersectionType).types as Iterable<AstType>)
      context.removeTypeIdMapping((type as AstIntersectionType).id)
    } else {
      types.append(type)
    }
  }

  let leftType = lowerType(context, id, cst.child.leftType)
  if leftType is Some<AstType> { appendType(leftType.unwrap()) }

  if cst.child.rightType is None<CstNode<CstType>> {
    context.addError(
      ExpectedTypeCompilerError(
        context.file,
        cst.cast<CstTrait | CstImpl | CstProperty | CstIntersectionType | CstUnionType>(),
      ),
    )
  } else {
    let rightType = lowerType(context, id, cst.child.rightType.unwrap())
    if rightType is Some<AstType> { appendType(rightType.unwrap()) }
  }

  context.addIdMapping(cst.id, id)
  AstIntersectionType(id, List.empty<AstIdentifier>(), types)
}
fun lowerUnionType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstUnionType>,
): AstUnionType {
  let id = context.getTypeId(parentId)

  let types = MutableList.empty<AstType>()
  let appendType = { type: AstType =>
    if type is AstUnionType {
      types.appendAll((type as AstUnionType).types as Iterable<AstType>)
      context.removeTypeIdMapping((type as AstUnionType).id)
    } else {
      types.append(type)
    }
  }

  let leftType = lowerType(context, id, cst.child.leftType)
  if leftType is Some<AstType> { appendType(leftType.unwrap()) }

  if cst.child.rightType is None<CstNode<CstType>> {
    context.addError(
      ExpectedTypeCompilerError(
        context.file,
        cst.cast<CstTrait | CstImpl | CstProperty | CstIntersectionType | CstUnionType>(),
      ),
    )
  } else {
    let rightType = lowerType(context, id, cst.child.rightType.unwrap())
    if rightType is Some<AstType> { appendType(rightType.unwrap()) }
  }

  context.addIdMapping(cst.id, id)
  AstUnionType(id, List.empty<AstIdentifier>(), types)
}

fun lowerTypeParameters(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: CstNode<CstTypeParameters>,
): List<AstTypeParameter> {
  let result = MutableList.empty<AstTypeParameter>()
  let previousNames = MutableMap.empty<String, Bool>()
  mut let punctuationExpectedNext = false
  for node in cst.child.typeParameters {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      let lowered = lowerTypeParameter(
        context,
        parentId,
        node.cast<CstTypeParameter>(),
        previousNames as Map<String, Bool>,
      )
      if lowered is Some<AstTypeParameter> {
        let unwrapped = lowered.unwrap()
        result.append(unwrapped)
        if unwrapped.name is Some<AstIdentifier> {
          previousNames.set(unwrapped.name.unwrap().value, true)
        }
      }
      punctuationExpectedNext = true
    }
  }

  if cst.child.closingAngleBracket is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}
fun lowerTypeParameter(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: CstNode<CstTypeParameter>,
  previousNames: Map<String, Bool>,
): Maybe<AstTypeParameter> {
  let name = cst.child.name
      .map<String>({ it.child.identifier })
      .orElse({ "unnamed-type-parameter-{context.getUnnamedDeclarationIndex()}" })
  if previousNames.containsKey(name) {
    context.addError(DuplicateTypeParameterNameCompilerError(context.file, cst))
    return None<AstTypeParameter>()
  }
  let id = AstTypeParameterId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })

  let upperBound = cst.child.upperBound
      .flatMap<AstType>({
        if it.second is None<CstNode<CstType>> {
          context.addError(ExpectedTypeInTypeParameterCompilerError(context.file, cst))
          None<AstType>()
        } else {
          lowerType(context, id, it.second.unwrap())
        }
      })

  context.addIdMapping(cst.id, id)
  Some<AstTypeParameter>(AstTypeParameter(id, modifiers, name, upperBound))
}

fun lowerTypeArguments(
  context: LoweringContext,
  parentId: AstTypeId | AstExpressionId,
  cst: CstNode<CstTypeArguments>,
): List<AstTypeArgument> {
  mut let index = 0
  let result = MutableList.empty<AstTypeArgument>()
  mut let punctuationExpectedNext = false
  for node in cst.child.typeArguments {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      result.append(lowerTypeArgument(context, parentId, node.cast<CstTypeArgument>(), index))
      index = index + 1
      punctuationExpectedNext = true
    }
  }

  if cst.child.closingAngleBracket is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}
fun lowerTypeArgument(
  context: LoweringContext,
  parentId: AstTypeId | AstExpressionId,
  cst: CstNode<CstTypeArgument>,
  index: Int,
): AstTypeArgument {
  let id = AstTypeArgumentId(parentId, index)

  let type = lowerType(context, id, cst.child.type)

  context.addIdMapping(cst.id, id)
  AstTypeArgument(id, type)
}

// expressions

fun lowerExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstExpression>,
): Maybe<AstExpression> {
  if cst.child is CstIntExpression {
    return lowerIntExpression(context, parentId, cst.cast<CstIntExpression>())
  }
  if cst.child is CstStringExpression {
    return lowerStringExpression(context, parentId, cst.cast<CstStringExpression>())
  }
  if cst.child is CstLambdaExpression {
    return lowerLambdaExpression(context, parentId, cst.cast<CstLambdaExpression>())
  }
  if cst.child is CstIdentifierExpression {
    return lowerIdentifierExpression(context, parentId, cst.cast<CstIdentifierExpression>())
  }
  if cst.child is CstGroupExpression {
    return lowerGroupExpression(context, parentId, cst.cast<CstGroupExpression>())
  }
  throw "Unknown expression: {cst}."
}

fun lowerIntExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstIntExpression>,
): Maybe<AstIntExpression> {
  let id = context.getExpressionId(parentId)
  context.addIdMapping(cst.id, id)
  Some<AstIntExpression>(AstIntExpression(id, cst.child.value.child.value))
}

fun lowerStringExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstStringExpression>,
): Maybe<AstStringExpression> {
  let id = context.getExpressionId(parentId)

  let parts = (cst.child.parts as Iterable<CstNode<StringPart>>)
      .map<AstStringPart>({
        if it.child is CstLiteralStringPart {
          return lowerLiteralStringPart(context, parentId, it.cast<CstLiteralStringPart>())
        }
        if it.child is CstEscapedStringPart {
          return lowerEscapedStringPart(context, parentId, it.cast<CstEscapedStringPart>())
        }
        if it.child is CstInterpolatedStringPart {
          return lowerInterpolatedStringPart(
            context,
            parentId,
            it.cast<CstInterpolatedStringPart>(),
          )
        }
        throw "Unknown string part: {it}."
      })
      .toList()

  context.addIdMapping(cst.id, id)
  Some<AstStringExpression>(AstStringExpression(id, parts))
}
fun lowerLiteralStringPart(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstLiteralStringPart>,
): AstStringPart {
  let id = context.getExpressionId(parentId)

  let identifierId = AstIdentifierId(id, 0)
  context.addIdMapping(cst.child.value.id, identifierId)
  let identifier = AstIdentifier(identifierId, cst.child.value.child.value)

  context.addIdMapping(cst.id, id)
  AstLiteralStringPart(id, identifier)
}
fun lowerEscapedStringPart(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstEscapedStringPart>,
): AstStringPart {
  let id = context.getExpressionId(parentId)

  let identifierId = AstIdentifierId(id, 0)
  let value = if cst.child.value is None<CstNode<StringLiteralToken>> {
    context.addError(InvalidEscapeSequenceCompilerError(context.file, cst))
    AstIdentifier(identifierId, "")
  } else {
    let escapeSequence = cst.child.value.unwrap()

    let validEscapeSequences = MutableMap.empty<String, String>()
    validEscapeSequences.set("ü¶Ñ", "\ü¶Ñ")
    validEscapeSequences.set("üëç", "\üëç")
    validEscapeSequences.set("n", "\n")
    validEscapeSequences.set("r", "\r")
    validEscapeSequences.set("t", "\t")
    validEscapeSequences.set("\\", "\\")

    let rawValue = escapeSequence.child.value
    let value = (validEscapeSequences as Map<String, String>)
      .get(rawValue)
      .orElse({
        context.addError(InvalidEscapeSequenceCompilerError(context.file, cst))
        rawValue
      })
    context.addIdMapping(escapeSequence.id, identifierId)
    AstIdentifier(identifierId, value)
  }

  context.addIdMapping(cst.id, id)
  AstLiteralStringPart(id, value)
}
fun lowerInterpolatedStringPart(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstInterpolatedStringPart>,
): AstStringPart {
  let id = context.getExpressionId(parentId)

  if cst.child.closingCurlyBrace is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  context.addIdMapping(cst.id, id)
  if cst.child.expression is Some<CstNode<CstExpression>> {
    lowerExpression(context, parentId, cst.child.expression.unwrap())
        .map<AstStringPart>({ AstInterpolatedStringPart(id, it) })
        .orElse({ AstLiteralStringPart(id, AstIdentifier(AstIdentifierId(id, 0), "")) })
  } else {
    context.addError(MissingExpressionInInterpolationCompilerError(context.file, cst))
    AstLiteralStringPart(id, AstIdentifier(AstIdentifierId(id, 0), ""))
  }
}

fun lowerLambdaExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstLambdaExpression>,
): Maybe<AstLambdaExpression> {
  let id = context.getExpressionId(parentId)

  let valueParameters = cst.child.valueParameters
      .map<List<AstValueParameter>>({ lowerLambdaExpressionValueParameters(context, id, it) })
      .orElse({ List.empty<AstValueParameter>() })

  let expressions = (cst.child.expressions as Iterable<CstNode<CstExpression>>)
      .map<Maybe<AstExpression>>({ lowerExpression(context, id, it)})
      .where({ it is Some<AstExpression> })
      .map<AstExpression>({ it.unwrap() })
      .toList()

  context.addIdMapping(cst.id, id)
  Some<AstLambdaExpression>(AstLambdaExpression(id, valueParameters, expressions))
}
fun lowerLambdaExpressionValueParameters(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstLambdaExpressionValueParameters>,
): List<AstValueParameter> {
  let id = context.getExpressionId(parentId)

  let valueParameters = lowerValueParameterList(context, id, cst.child.valueParameters)

  context.addIdMapping(cst.id, id)
  valueParameters
}

fun lowerIdentifierExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstIdentifierExpression>,
): Maybe<AstIdentifierExpression> {
  let id = context.getExpressionId(parentId)

  let value = lowerIdentifier(context, id, cst.child.value, 0)

  context.addIdMapping(cst.id, id)
  Some<AstIdentifierExpression>(AstIdentifierExpression(id, value))
}

fun lowerGroupExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstGroupExpression>,
): Maybe<AstExpression> {
  let expression = if cst.child.expression is None<CstNode<CstExpression>> {
    context.addError(
      ExpectedExpressionCompilerError(
        context.file,
        cst.cast<CstExpressionBody | CstDelegationBody | CstGroupExpression>(),
      ),
    )
    None<AstExpression>()
  } else {
    lowerExpression(context, parentId, cst.child.expression.unwrap())
  }

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  return expression
}

// utility

class LoweringContext {
  static fun create(file: File): LoweringContext {
    LoweringContext(
      file,
      MutableMap.empty<CstNodeId, AstNodeId>(),
      0,
      0,
      0,
      MutableList.empty<CompilerError>(),
    )
  }

  let file: File

  let idMapping: MutableMap<CstNodeId, AstNodeId>
  fun addIdMapping(cstId: CstNodeId, astId: AstNodeId) {
    assert(
      !(idMapping as Map<CstNodeId, AstNodeId>).containsKey(cstId),
      "ID {cstId} already lowered to {astId}.",
    )
    idMapping.set(cstId, astId)
  }
  fun removeTypeIdMapping(astId: AstTypeId) {
    idMapping.removeWhere({ _, value =>
      if !(value is AstTypeId) { return false }
      // TODO(JonasWanke): this only works because type IDs are currently numbered per file
      (value as AstTypeId).value == astId.value
    })
  }
  mut let nextUnnamedDeclarationIndex: Int
  fun getUnnamedDeclarationIndex(): Int {
    let index = nextUnnamedDeclarationIndex
    nextUnnamedDeclarationIndex = nextUnnamedDeclarationIndex + 1
    index
  }

  mut let nextTypeId: Int
  fun getTypeId(
    parentId: AstDeclarationId
      | AstTypeId
      | AstTypeParameterId
      | AstTypeArgumentId
      | AstValueParameterId
      | AstExpressionId,
    ): AstTypeId {
    // TODO(JonasWanke): number these per parent when IDs implement `Equals & Hash`

    let id = AstTypeId(parentId, nextTypeId)
    nextTypeId = nextTypeId + 1
    id
  }

  mut let nextExpressionId: Int
  fun getExpressionId(
    parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  ): AstExpressionId {
    // TODO(JonasWanke): number these per parent when IDs implement `Equals & Hash`

    let id = AstExpressionId(parentId, nextExpressionId)
    nextExpressionId = nextExpressionId + 1
    id
  }

  let errors: MutableList<CompilerError>
  fun addError(error: CompilerError) { errors.append(error) }

  fun getResult(): (Map<CstNodeId, AstNodeId>, List<CompilerError>) {
    Tuple(idMapping, errors)
  }
}
