use ast
use compiler_utils
use incremental

use ..declarations
use ..file
use ..resolving
use ...declarations
use ...expressions
use ...file
use ...types

fun lowerFunctionBody(
  context: QueryContext<List<CompilerError>>,
  function: HirFunction,
): (List<HirValueExpressionUri>, Map<HirValueExpressionUri, HirValueExpression>) {
  query<(List<HirValueExpressionUri>, Map<HirValueExpressionUri, HirValueExpression>), List<CompilerError>>(context, "lowerFunctionBody", function, {
    let ast = function.ast(context)
    let context = LoweringContext(
      BodyGlobalState(
        function,
        MutableMap.empty<HirValueExpressionUri, HirValueExpression>(),
        0,
        MutableList.empty<CompilerError>(),
      ),
      None<LoweringContext>(),
      MutableMap.empty<String, HirValueExpressionUri>(),
    )
    todo("")
  })
}

class BodyGlobalState {
  let function: HirFunction
  let expressions: MutableMap<HirValueExpressionUri, HirValueExpression>
  mut let nextExpressionId: Int
  let errors: MutableList<CompilerError>
}
class LoweringContext {
  let global: BodyGlobalState
  let parent: Maybe<LoweringContext>
  let localProperties: MutableMap<String, HirValueExpressionUri>
}
impl LoweringContext {
  fun register(expression: HirValueExpression): HirValueExpressionUri {
    let uri = HirValueExpressionUri(
      this.global.function,
      this.global.nextExpressionId,
    )
    this.global.nextExpressionId = this.global.nextExpressionId + 1
    this.global.expressions.set(uri, expression)
    uri
  }

  fun registerError(error: CompilerError): HirValueExpressionUri {
    this.global.errors.append(error)
    this.register(HirErrorValueExpression())
  }

  fun resolve(
    context: QueryContext<List<CompilerError>>,
    name: String,
  ): Set<HirValueExpressionUri | HirModule | HirType | HirTrait | HirFunction | HirParameterType> {
    (this.localProperties as Map<String, HirValueExpressionUri>).get(name)
      .map<Set<HirValueExpressionUri | HirModule | HirType | HirTrait | HirFunction | HirParameterType>>({
        Set.of1<HirValueExpressionUri | HirModule | HirType | HirTrait | HirFunction | HirParameterType>(it)
      })
      .orElse({
        this.parent
          .map<Set<HirValueExpressionUri | HirModule | HirType | HirTrait | HirFunction | HirParameterType>>({
            it.resolve(context, name)
          })
          .orElse({
            (resolveIdentifier(context, name, this.global.function) as Set<HirValueExpressionUri | HirModule | HirType | HirTrait | HirFunction | HirParameterType>)
          })
      })
  }

  fun lowerExpressionToValueExpression(
    context: QueryContext<List<CompilerError>>,
    expression: AstExpression,
  ): HirValueExpressionUri {
    let lowered = this.lowerExpression(context, expression)
    if (lowered is HirTypeExpression || lowered is HirModuleExpression) {
      this.registerError(InvalidValueExpressionError(lowered as HirTypeExpression | HirModuleExpression))
    } else {
      (lowered as HirValueExpressionUri)
    }
  }

  /// Lowers and registers the expression on this context and returns the uri.
  fun lowerExpression(
    context: QueryContext<List<CompilerError>>,
    expression: AstExpression,
  ): HirValueExpressionUri | HirTypeExpression | HirModuleExpression {
    if (expression is AstIntExpression) {
      return this.register(HirIntValueExpression((expression as AstIntExpression).value))
    }

    if (expression is AstStringExpression) {
      // For String expressions, the interpolation is desugared string into multiple calls to `+`.
      // "{name} is a great {type}" -> "" + name + " is a great " + type
      mut let stringUri = this.register(HirStringValueExpression(""))

      for part in (expression as AstStringExpression).parts {
        let expressionToAdd: HirValueExpression = if (part is AstLiteralStringPart) {
          HirStringValueExpression((part as AstLiteralStringPart).value.value)
        } else {
          let expressionToStringify = this.lowerExpressionToValueExpression(
            context,
            (part as AstInterpolatedStringPart).expression,
          )
          let expressionType = typeOf(
            context,
            this.global.function,
            this.global.expressions,
            expressionToStringify,
          )
          let implementsToString = isAssignableTo(
            context,
            expressionType,
            HirTrait.coreString(context),
            (this.global.function as HasPackageAndPath).package(),
          )
          if (!implementsToString) {
            this.registerError(InvalidInterpolatedExpressionError(expressionToStringify))
          } else {
            this.register(HirFunctionCallValueExpression(
              Some<HirValueExpressionUri | HirTypeExpression>(expressionToStringify),
              HirFunction.coreToString(context),
              Map.empty<String, HirInlineType>(),
              Map.empty<String, HirValueExpressionUri>(),
            ))
          }
        }

        stringUri = this.register(HirFunctionCallValueExpression(
          stringUri,
          // TODO(marcelgarus): Directly call the `String`'s `add` function for better performance
          // (and in case someone implements `+` for `String` a second time).
          HirFunction.infixPlus(context),
          Map.empty<String, HirInlineType>(),
          Map.of1<String, HirValueExpressionUri>(Tuple("other", this.register(expressionToAdd))),
        ))
      }
      return stringUri
    }

    if (expression is AstLambdaExpression) {
      let expression = (expression as AstLambdaExpression)
      return this.register(HirLambdaValueExpression(
        (expression.valueParameters as Iterable<AstValueParameter>)
          .map<HirLambdaParameter>({ this.lowerParameter(context, it) })
          .toList(),
        (expression.expressions as Iterable<AstExpression>)
          .map<HirValueExpressionUri>({ this.lowerExpressionToValueExpression(context, it) })
          .toList(),
      ))
    }

    if (expression is AstIdentifierExpression) {
      let expression = (expression as AstIdentifierExpression)
      let name = expression.identifier.name
      let possibleProperties = this.resolve(context, name)
      if (possibleProperties.isEmpty()) {
        return this.registerError(UnresolvedIdentifierError(name))
      }

      let property = possibleProperties.first().unwrap()

      if (property is HirFunction) {
        return this.registerError(UncalledFunctionError(property as HirFunction))
      }
      assert(possibleProperties.length() == 1, "Ambiguous lowering can only occur for overloaded functions.")

      if (property is HirValueExpressionUri) {
        if ((expression.typeArguments as Iterable<AstTypeArgument>).isNotEmpty()) {
          this.registerError(InvalidTypeArgumentsError(property as HirValueExpressionUri))
        }
        return (property as HirValueExpressionUri)
      }

      if (property is HirModule) {
        if ((expression.typeArguments as Iterable<AstTypeArgument>).isNotEmpty()) {
          this.registerError(InvalidTypeArgumentsError(property as HirModule))
        }
        return HirModuleExpression(property as HirModule)
      }

      if (property is HirParameterType) {
        if ((expression.typeArguments as Iterable<AstTypeArgument>).isNotEmpty()) {
          this.registerError(InvalidTypeArgumentsError(property as HirParameterType))
        }
        return (property as HirParameterType)
      }

      // That leaves us with `HirType` and `HirTrait` and lots of fun…
      let typeArguments = (expression.typeArguments as Iterable<AstTypeArgument>)
        .map<HirInlineType>({
          astInlineTypeToHirInlineType(context, it.type, this.global.function)
        })
        .toList()
      
      let typeParameters = (property as HasTypeParameters).typeParameters(context)
      let suppliedTypeArgumentCount = (typeArguments as Iterable<HirInlineType>).length()
      let requiredTypeArgumentCount = (typeParameters as Iterable<HirParameterType>).length()
      if (!(suppliedTypeArgumentCount == requiredTypeArgumentCount)) {
        return this.registerError(
          WrongNumberOfTypeArgumentsError(suppliedTypeArgumentCount, requiredTypeArgumentCount),
        )
      }

      let anyTypeArgumentIsInvalid = (typeArguments as Iterable<HirInlineType>)
        .zip<HirParameterType>(typeParameters)
        .any({
          let argument = it.first
          let parameter = it.second
          let upperBound = parameter.upperBound(context)
          if (!isAssignableTo(context, argument, upperBound, (this.global.function as HasPackageAndPath).package())) {
            context.registerError(InvalidTypeArgumentError(argument, upperBound))
            return false
          }
          true
        })
      if (anyTypeArgumentIsInvalid) { return this.register(HirErrorValueExpression()) }

      return HirNamedType(parameter as HirTrait | HirType, typeArguments)
    }

    if (expression is AstTupleExpression) {
      let expression = (expression as AstTupleExpression)
      return HirTupleValueExpression(
        (expression.expressions as Iterable<AstExpression>)
          .map<HirValueExpressionUri>({ this.lowerExpressionToValueExpression(context, it) })
          .toList(),
      )
    }

    if (expression is AstBinaryExpression) {
      let expression = (expression as AstBinaryExpression)
      mut let function = HirFunction.infixEqualEqual(context)
      let name = expression.identifier.name
      if (name == "==") { function = HirFunction.infixEqualEqual(context) }
      if (name == "!=") { function = HirFunction.infixExclamationEqual(context) }
      if (name == "<")  { function = HirFunction.infixLess(context) }
      if (name == "<=") { function = HirFunction.infixLessEqual(context) }
      if (name == ">")  { function = HirFunction.infixGreater(context) }
      if (name == ">=") { function = HirFunction.infixGreaterEqual(context) }
      if (name == "+")  { function = HirFunction.infixPlus(context) }
      if (name == "-")  { function = HirFunction.infixMinus(context) }
      if (name == "*")  { function = HirFunction.infixStar(context) }
      if (name == "/")  { function = HirFunction.infixSlash(context) }
      if (name == "//") { function = HirFunction.infixSlashSlash(context) }
      if (name == "%")  { function = HirFunction.infixPercent(context) }
      if (name == "&")  { function = HirFunction.infixAmpersand(context) }
      if (name == "|")  { function = HirFunction.infixBar(context) }
      if (name == "=>") { function = HirFunction.infixEqualGreater(context) }
      return HirFunctionCallValueExpression(
        this.lowerExpressionToValueExpression(expression.leftOperand),
        function,
        Map.empty<String, HirInlineType>(),
        Map.of1<String, HirValueExpressionUri>(
          Tuple("other", this.lowerExpressionToValueExpression(expression.rightOperand)),
        ),
      )
    }

    if (expression is AstPropertyExpression) {
      let expression = (expression as AstPropertyExpression)
      let uri = this.lowerExpression(context, expression.initializer.unwrap())
      this.localProperties.put(expression.name, uri)
    }

    if (expression is AstNavigationExpression) {
      // This is an AstNavigationExpression that has is not inside an AstCallExpression – otherwise,
      // the lowering of the surrounding AstCallExpression would have also handled the inner
      // AstNavigationExpression. So, this is a function invocation without any parameters.
      // But that doesn't work for now.
      todo("Function call with omitted parentheses")
    }

    if (expression is AstCallExpression) {
      let expression = (expression as AstCallExpression)
      let receiver = expression.receiver

      let nameAndReceiver = if (receiver is AstIdentifierExpression) {
        Tuple((receiver as AstIdentifierExpression).value.name, None<HirValueExpressionUri>())
      } else {
        Tuple(
          (receiver as AstNavigationExpression).target.name,
          Some<HirValueExpressionUri>(this.lowerExpressionToValueExpression(receiver.receiver)),
        )
      }
      let name = nameAndReceiver.first
      let receiver = nameAndReceiver.second

      let function: HirFunction = this.resolve(context, name)
      // TODO: Support overloading.
      let function = if (function.length() == 1) {
        function.single().unwrap()
      } else {
        return this.registerError(UnsupportedFeatureCompilerError(
          None<Location>(),
          "Function overloading is not yet supported.",
        ))
      }

      // TODO: This is a work in progress. Continue working on it.
      let typeArguments = expression.typeArguments.map<String, HirInlineType>({ name, value =>
        Tuple(
          name,
          astInlineTypeToHirInlineType(context, value, this.global.function),
        )
      })
      let valueArguments = expression.valueArguments.map<String, HirValueExpressionUri>({ name, value =>
        Tuple(
          name,
          this.lowerExpressionToValueExpression(context, it),
        )
      })

      return HirFunctionCallValueExpression(receiver, function, typeArguments, valueArguments)
    }

    if (expression is AstReturnExpression) {
      let expression = (expression as AstReturnExpression)
      let returnValue = expression.value.orElse({ HirExpression.unit(context) })
      return HirReturnValueExpression(
        this.global.function,
        this.lowerExpressionToValueExpression(context, returnValue),
      )
    }

    assert(false, "Unreachable")
  }

  fun lowerParameter(context: QueryContext<List<CompilerError>>, parameter: AstValueParameter): HirLambdaParameter {
    HirLambdaParameter(
      parameter.name.value,
      // TODO(marcelgarus): Support type inference for parameters.
      parameter.type.map<HirInlineType>({ astInlineTypeToHirInlineType(context, it) })
        .expect("Lambda parameter without specified type."),
    )
  }
}

public class InvalidValueExpressionError {
  public let expression: HirTypeExpression | HirModuleExpression
}
impl InvalidValueExpressionError: CompilerError {
  public fun id(): String { "invalid-value-expression" }

  public fun location(): Location {
    todo("Implement InvalidValueExpressionError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "Cannot use this expression here; expected a value expression." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    "This is the non-value expression: {this.expression}"
  }
}

public class InvalidInterpolatedExpressionError {
  public let expression: HirValueExpressionUri
}
impl InvalidInterpolatedExpressionError: CompilerError {
  public fun id(): String { "invalid-interpolated-expression" }

  public fun location(): Location {
    todo("Implement InvalidInterpolatedExpressionError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "This expression does not implement ToString." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    "This is the non-ToString expression: {this.expression}"
  }
}

public class UnresolvedIdentifierError {
  public let identifier: String
}
impl UnresolvedIdentifierError: CompilerError {
  public fun id(): String { "unresolved-identifier" }

  public fun location(): Location {
    todo("Implement UnresolvedIdentifierError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "Unresolved identifier." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    "The unresolved identifier is {this.identifier}."
  }
}

public class UncalledFunctionError {
  public let function: HirFunction
}
impl UncalledFunctionError: CompilerError {
  public fun id(): String { "uncalled-function" }

  public fun location(): Location {
    todo("Implement UncalledFunctionError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "You didn't call a function." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    "The uncalled function or one of the overloads is {this.function}."
  }
}

public class InvalidTypeArgumentsError {
  public let inner: HirValueExpressionUri | HirModule | HirParameterType
}
impl InvalidTypeArgumentsError: CompilerError {
  public fun id(): String { "invalid-type-arguments" }

  public fun location(): Location {
    todo("Implement InvalidTypeArgumentsError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "Cannot add type arguments to module or type parameter references, or some expressions." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    "This is the improper expression: {this.inner}"
  }
}

public class WrongNumberOfTypeArgumentsError {
  public let suppliedCount: Int
  public let requiredCount: Int
}
impl WrongNumberOfTypeArgumentsError: CompilerError {
  public fun id(): String { "wrong-number-of-type-arguments" }

  public fun location(): Location {
    todo("Implement WrongNumberOfTypeArgumentsError.location") // TODO(marcelgarus)
  }
  public fun title(): String {
    "Wrong number of type arguments were supplied: {this.suppliedCount}, required: {this.requiredCount}."
  }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    ""
  }
}
public class InvalidTypeArgumentError {
  public let actualType: HirInlineType
  public let upperBound: HirInlineType
}
impl InvalidTypeArgumentError: CompilerError {
  public fun id(): String { "invalid-type-arguments" }

  public fun location(): Location {
    todo("Implement InvalidTypeArgumentError.location") // TODO(marcelgarus)
  }
  public fun title(): String {
    "Type argument is not assignable to the type parameter's upper bound."
  }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    "Type argument was {this.actualType}, but is not assignable to {this.upperBound}."
  }
}
