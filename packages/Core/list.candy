builtins = use "Builtins"
bool = use "..bool"
[ifElse, recursive] = use "..controlFlow"
[equals] = use "..equality"
function = use "..function"
int = use "..int"
result = use "..result"
type = use "..type"

is value := type.is value List

length := builtins.listLength
isEmpty list :=
  needs (is list)
  equals (length list) 0

lastIndex list :=
  needs (is list)
  ifElse (list | isEmpty) { Error "Can't get the last index of an empty list." } {
    Ok (list | length | int.subtract 1)
  }
isValidIndex list index :=
  needs (is list)
  needs (int.is index)
  ifElse (list | isEmpty) { False } { index | int.isNonNegative }
  | bool.lazyAnd { index | int.isLessThanOrEqualTo (list | lastIndex | result.unwrap) }
isValidInsertIndex list index :=
  needs (is list)
  needs (int.is index)
  ifElse (list | isEmpty) { False } { index | int.isNonNegative }
  | bool.lazyAnd { index | int.isLessThanOrEqualTo (list | length) }

get := builtins.listGet

single list :=
  needs (is list)
  list %
    (,) -> Error "Can't get the single item of an empty list."
    (item,) -> Ok item
    _ -> Error "Can't get the single item of a list with more than one item."
first list :=
  needs (is list)
  list %
    (,) -> Error "Can't get the first item of an empty list."
    _ -> Ok (list | get 0)
last list :=
  needs (is list)
  list | lastIndex | result.mapError { _ -> "Can't get the last item of an empty list." }
  | result.map { index -> list | get index }

insert := builtins.listInsert

prepend list item :=
  needs (is list)
  list | insert 0 item
append list item :=
  needs (is list)
  list | insert (length list) item

replace := builtins.listReplace
update list index updater :=
  needs (is list)
  needs (int.is index)
  needs (list | isValidIndex index)
  needs (function.is1 updater)
  oldValue = list | get index
  newValue = updater oldValue
  list | replace index newValue

removeAt := builtins.listRemoveAt

filled := builtins.listFilled
generate length valueGetter :=
  # Creates a new list of the given `length`, where each slot is filled by calling `valueGetter`
  # with the index.
  needs (int.is length)
  needs (int.isNonNegative length)
  needs (int.fitsInRustU32 length)
  needs (function.is1 valueGetter)

  list = filled length Placeholder
  recursive [list, Index: 0] { recurse [list, index] ->
    ifElse (index | equals length) { list } {
      item = valueGetter index
      list = list | replace index item
      recurse [list, Index: int.add index 1]
    }
  }

getRange list startInclusive endExclusive :=
  needs (is list)
  needs (int.is startInclusive)
  needs (startInclusive | int.isNonNegative)
  needs (startInclusive | int.isLessThanOrEqualTo (list | length))
  needs (int.is endExclusive)
  needs (endExclusive | int.isNonNegative)
  needs (endExclusive | int.isLessThanOrEqualTo (list | length))
  needs (startInclusive | int.isLessThanOrEqualTo endExclusive)
  generate (endExclusive | int.subtract startInclusive) { index ->
    list | get (startInclusive | int.add index)
  }

concatenate listA listB :=
  needs (is listA)
  needs (is listB)
  generate (listA | length | int.add (listB | length)) { index ->
    ifElse (index | int.isLessThan (listA | length)) { listA | get index } {
      listB | get (index | int.subtract (listA | length))
    }
  }
