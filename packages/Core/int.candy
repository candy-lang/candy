builtins = use "Builtins"
bool = use "..bool"
[check] = use "..check"
[ifElse, recursive] = use "..controlFlow"
[equals] = use "..equality"
type = use "..type"

is value := type.is value Int

theAnswer := 42

add := builtins.intAdd
subtract := builtins.intSubtract
negate value :=
  needs (is value)
  subtract 0 value
multiply := builtins.intMultiply
divideTruncating := builtins.intDivideTruncating
remainder := builtins.intRemainder
modulo := builtins.intModulo

compareTo valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  result = valueA | builtins.intCompareTo valueB
  check (result | equals Equal | bool.implies (equals valueA valueB))
  result
isLessThan valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  valueA | compareTo valueB | equals Less
isGreaterThan valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  valueA | compareTo valueB | equals Greater
isLessThanOrEqualTo valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  valueA | isGreaterThan valueB | bool.not
isGreaterThanOrEqualTo valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  valueA | isLessThan valueB | bool.not

isPositive value :=
  needs (is value)
  value | isGreaterThan 0
isNonPositive value :=
  needs (is value)
  value | isPositive | bool.not
isNegative value :=
  needs (is value)
  value | isLessThan 0
isNonNegative value :=
  needs (is value)
  value | isNegative | bool.not
absolute value :=
  needs (is value)
  ifElse (isNegative value) { negate value } { value }

isUnsignedByte value :=
  is value | bool.lazyAnd { value | isNonNegative } | bool.lazyAnd { value | isLessThan 256 }
fitsInRustU32 value :=
  needs (is value)
  needs (isNonNegative value)

  rustU32Max = 4294967295
  # https://doc.rust-lang.org/std/primitive.u32.html#associatedconstant.MAX
  value | isLessThan rustU32Max
fitsInRustU128 value :=
  needs (is value)
  needs (isNonNegative value)

  rustU128Max = 340282366920938463463374607431768211455
  # https://doc.rust-lang.org/std/primitive.u128.html#associatedconstant.MAX
  value | isLessThan rustU128Max

shiftLeft := builtins.intShiftLeft
shiftRight := builtins.intShiftRight

bitLength := builtins.intBitLength

bitwiseAnd := builtins.intBitwiseAnd
bitwiseOr := builtins.intBitwiseOr
bitwiseXor := builtins.intBitwiseXor

lowestBits value bitCount :=
  needs (is value)
  needs (is bitCount)
  needs (isPositive bitCount)
  mask = 1 | shiftLeft bitCount | subtract 1
  value | bitwiseAnd mask

isEven value :=
  needs (is value)
  value | bitwiseAnd 1 | equals 0
isOdd value :=
  needs (is value)
  isOdd = value | bitwiseAnd 1 | equals 1
  check (value | isEven | equals (isOdd | bool.not))
  isOdd

min valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  ifElse (valueA | isLessThanOrEqualTo valueB) { valueA } { valueB }
max valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  ifElse (valueA | isGreaterThanOrEqualTo valueB) { valueA } { valueB }
coerceAtLeast value minimum :=
  needs (is value)
  needs (is minimum)
  max value minimum
coerceAtMost value maximum :=
  needs (is value)
  needs (is maximum)
  min value maximum
coerceIn value minimum maximum :=
  needs (is value)
  needs (is minimum)
  needs (is maximum)
  needs (minimum | isLessThanOrEqualTo maximum)
  value | coerceAtLeast minimum | coerceAtMost maximum

parse := builtins.intParse

pow base exponent :=
  needs (is base)
  needs (is exponent)
  needs (isNonNegative exponent)
  recursive [base, exponent] { recurse params ->
    [base, exponent] = params
    exponent %
      0 -> 1
      _ ->
        ifElse
          exponent | isEven
          { recurse [Base: base | multiply base, Exponent: exponent | shiftRight 1] }
          {
            base
            | multiply
              recurse [Base: base | multiply base, Exponent: exponent | subtract 1 | shiftRight 1]
          }
  }
